diff --git a/node_modules/three/build/three.module.js b/node_modules/three/build/three.module.js
index 2bcabf7..4897399 100644
--- a/node_modules/three/build/three.module.js
+++ b/node_modules/three/build/three.module.js
@@ -20743,7 +20743,9 @@ function WebGLShadowMap( _renderer, _objects, _capabilities ) {
 
 			if ( cachedMaterial === undefined ) {
 
-				cachedMaterial = result.clone();
+				// if user explicitly passed custom material, cloning seems unnecessary
+				// and clobbers any onBeforeCompile, etc properties ignored in clone
+				cachedMaterial = customMaterial !== undefined ? result : result.clone();
 				materialsForVariant[ keyB ] = cachedMaterial;
 
 			}
diff --git a/node_modules/three/examples/jsm/csm/CSM.js b/node_modules/three/examples/jsm/csm/CSM.js
index c96e627..52580c0 100644
--- a/node_modules/three/examples/jsm/csm/CSM.js
+++ b/node_modules/three/examples/jsm/csm/CSM.js
@@ -30,6 +30,7 @@ export class CSM {
 		this.mode = data.mode || 'practical';
 		this.shadowMapSize = data.shadowMapSize || 2048;
 		this.shadowBias = data.shadowBias || 0.000001;
+		this.lightColor = data.lightColor || 0xffffff;
 		this.lightDirection = data.lightDirection || new Vector3( 1, - 1, 1 ).normalize();
 		this.lightIntensity = data.lightIntensity || 1;
 		this.lightNear = data.lightNear || 1;
@@ -54,7 +55,7 @@ export class CSM {
 
 		for ( let i = 0; i < this.cascades; i ++ ) {
 
-			const light = new DirectionalLight( 0xffffff, this.lightIntensity );
+			const light = new DirectionalLight( this.lightColor, this.lightIntensity );
 			light.castShadow = true;
 			light.shadow.mapSize.width = this.shadowMapSize;
 			light.shadow.mapSize.height = this.shadowMapSize;
@@ -239,12 +240,17 @@ export class CSM {
 
 	injectInclude() {
 		
+		// backup original shader chunks
+		ShaderChunk.lights_fragment_begin_bkp = ShaderChunk.lights_fragment_begin;
+		ShaderChunk.lights_pars_begin_bkp = ShaderChunk.lights_pars_begin;
+
+		// replace lighting shaders with CSM customizations
 		ShaderChunk.lights_fragment_begin = CSMShader.lights_fragment_begin;
 		ShaderChunk.lights_pars_begin = CSMShader.lights_pars_begin;
 
 	}
 
-	setupMaterial( material ) {
+	setupMaterial( material, preexistingOnBeforeCompile ) {
 
 		material.defines = material.defines || {};
 		material.defines.USE_CSM = 1;
@@ -260,7 +266,11 @@ export class CSM {
 		const scope = this;
 		const shaders = this.shaders;
 
+		material.userData.preexistingOnBeforeCompile = preexistingOnBeforeCompile;
 		material.onBeforeCompile = function ( shader ) {
+			if (preexistingOnBeforeCompile) {
+				preexistingOnBeforeCompile(shader);
+			}
 
 			const far = Math.min( scope.camera.far, scope.maxFar );
 			scope.getExtendedBreaks( breaksVec2 );
@@ -344,6 +354,7 @@ export class CSM {
 		for ( let i = 0; i < this.lights.length; i ++ ) {
 
 			this.parent.remove( this.lights[ i ] );
+			this.lights[ i ].dispose();
 
 		}
 
@@ -351,10 +362,18 @@ export class CSM {
 
 	dispose() {
 
+		// undo ShaderChunk rewrites
+		ShaderChunk.lights_fragment_begin = ShaderChunk.lights_fragment_begin_bkp;
+		ShaderChunk.lights_pars_begin = ShaderChunk.lights_pars_begin_bkp;
+
 		const shaders = this.shaders;
 		shaders.forEach( function ( shader, material ) {
 
-			delete material.onBeforeCompile;
+			if (material.userData.preexistingOnBeforeCompile) {
+				material.onBeforeCompile = material.userData.preexistingOnBeforeCompile;
+			} else {
+				delete material.onBeforeCompile;
+			}
 			delete material.defines.USE_CSM;
 			delete material.defines.CSM_CASCADES;
 			delete material.defines.CSM_FADE;
