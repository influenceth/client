diff --git a/node_modules/@argent/x-sessions/dist/account.d.ts b/node_modules/@argent/x-sessions/dist/account.d.ts
index 0f0ac18..5b6d409 100644
--- a/node_modules/@argent/x-sessions/dist/account.d.ts
+++ b/node_modules/@argent/x-sessions/dist/account.d.ts
@@ -3,11 +3,13 @@ import { SignedSession } from "./utils";
 export declare class SessionAccount extends Account implements AccountInterface {
     signedSession: SignedSession;
     merkleTree: merkle.MerkleTree;
+    private openTransactions;
     constructor(providerOrOptions: ProviderOptions | ProviderInterface, address: string, keyPairOrSigner: KeyPair | SignerInterface, signedSession: SignedSession);
     private sessionToCall;
     private proofCalls;
     private extendCallsBySession;
     estimateInvokeFee(calls: Call | Call[], { nonce: providedNonce, blockIdentifier }?: EstimateFeeDetails): Promise<EstimateFee>;
+    getOpenTransactionsCount(): Promise<number>;
     /**
      * Invoke execute function in account contract
      *
diff --git a/node_modules/@argent/x-sessions/dist/sessions.js b/node_modules/@argent/x-sessions/dist/sessions.js
index 9620562..5000101 100644
--- a/node_modules/@argent/x-sessions/dist/sessions.js
+++ b/node_modules/@argent/x-sessions/dist/sessions.js
@@ -1,32 +1,32 @@
 var k = Object.defineProperty;
-var T = (s, t, e) => t in s ? k(s, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[t] = e;
-var g = (s, t, e) => (T(s, typeof t != "symbol" ? t + "" : t, e), e);
-import { stark as h, number as l, hash as m, typedData as F, merkle as I, Account as b, constants as N, transaction as y } from "starknet";
-const A = "0x31c70ed28f4b0faf39b2f97d8f0a61a36968319c13fe6f2051b8de5a15f3d9b", v = "0x2f0026e78543f036f33e26a8f5891b88c58dc1e20cbbfaf0bb53274da6fa568";
-async function _(s, t) {
-  const { result: e } = await t.callContract({
-    contractAddress: s,
+var E = (a, s, e) => s in a ? k(a, s, { enumerable: !0, configurable: !0, writable: !0, value: e }) : a[s] = e;
+var g = (a, s, e) => (E(a, typeof s != "symbol" ? s + "" : s, e), e);
+import { stark as y, number as c, hash as T, typedData as N, merkle as v, Account as F, constants as P, transaction as A } from "starknet";
+const C = "0x31c70ed28f4b0faf39b2f97d8f0a61a36968319c13fe6f2051b8de5a15f3d9b", b = "0x2f0026e78543f036f33e26a8f5891b88c58dc1e20cbbfaf0bb53274da6fa568";
+async function M(a, s) {
+  const { result: e } = await s.callContract({
+    contractAddress: a,
     entrypoint: "isPlugin",
-    calldata: h.compileCalldata({ classHash: A })
+    calldata: y.compileCalldata({ classHash: C })
   });
-  return !l.toBN(e[0]).isZero();
+  return !c.toBN(e[0]).isZero();
 }
-function x({ contractAddress: s, selector: t }) {
-  return m.computeHashOnElements([
-    v,
-    s,
-    F.prepareSelector(t)
+function w({ contractAddress: a, selector: s }) {
+  return T.computeHashOnElements([
+    b,
+    a,
+    N.prepareSelector(s)
   ]);
 }
-function S(s) {
-  return new I.MerkleTree(s.map(x));
+function S(a) {
+  return new v.MerkleTree(a.map(w));
 }
-function E(s) {
-  const { root: t } = S(s.policies);
-  return { ...s, root: t };
+function B(a) {
+  const { root: s } = S(a.policies);
+  return { ...a, root: s };
 }
-async function M(s, t) {
-  const { expires: e, key: n, policies: a, root: r } = E(s), o = await t.signMessage({
+async function L(a, s) {
+  const { expires: e, key: t, policies: n, root: o } = B(a), r = await s.signMessage({
     primaryType: "Session",
     types: {
       Policy: [
@@ -41,53 +41,54 @@ async function M(s, t) {
       StarkNetDomain: [{ name: "chainId", type: "felt" }]
     },
     domain: {
-      chainId: t.chainId
+      chainId: s.chainId
     },
     message: {
-      key: n,
+      key: t,
       expires: e,
-      root: a
+      root: n
       // we can pass the policy to the message, when argent x works with type merkletree (starknet.js update)
     }
   });
   return {
-    key: n,
-    policies: a,
+    key: t,
+    policies: n,
     expires: e,
-    root: r,
-    signature: o
+    root: o,
+    signature: r
   };
 }
-var P = w;
-function w(s, t) {
-  if (!s)
-    throw new Error(t || "Assertion failed");
+var O = I;
+function I(a, s) {
+  if (!a)
+    throw new Error(s || "Assertion failed");
 }
-w.equal = function(t, e, n) {
-  if (t != e)
-    throw new Error(n || "Assertion failed: " + t + " != " + e);
+I.equal = function(s, e, t) {
+  if (s != e)
+    throw new Error(t || "Assertion failed: " + s + " != " + e);
 };
-class L extends b {
-  constructor(e, n, a, r) {
-    super(e, n, a);
+class R extends F {
+  constructor(e, t, n, o) {
+    super(e, t, n);
     g(this, "merkleTree");
-    this.signedSession = r, this.merkleTree = S(r.policies), P(r.root === this.merkleTree.root, "Invalid session");
+    g(this, "openTransactions", []);
+    this.signedSession = o, this.merkleTree = S(o.policies), O(o.root === this.merkleTree.root, "Invalid session");
   }
-  async sessionToCall(e, n) {
+  async sessionToCall(e, t) {
     return {
       contractAddress: this.address,
       entrypoint: "use_plugin",
-      calldata: h.compileCalldata({
-        classHash: A,
+      calldata: y.compileCalldata({
+        classHash: C,
         signer: await this.signer.getPubKey(),
         expires: e.expires.toString(),
         root: e.root,
-        proofLength: n[0].length.toString(),
-        ...n.reduce(
-          (a, r, o) => ({
-            ...a,
-            ...r.reduce(
-              (i, c, d) => ({ ...i, [`proof${o}:${d}`]: c }),
+        proofLength: t[0].length.toString(),
+        ...t.reduce(
+          (n, o, r) => ({
+            ...n,
+            ...o.reduce(
+              (i, l, d) => ({ ...i, [`proof${r}:${d}`]: l }),
               {}
             )
           }),
@@ -99,45 +100,58 @@ class L extends b {
     };
   }
   proofCalls(e) {
-    return e.map((n) => {
-      const a = x({
-        contractAddress: n.contractAddress,
-        selector: n.entrypoint
+    return e.map((t) => {
+      const n = w({
+        contractAddress: t.contractAddress,
+        selector: t.entrypoint
       });
-      return this.merkleTree.getProof(a);
+      return this.merkleTree.getProof(n);
     });
   }
-  async extendCallsBySession(e, n) {
-    const a = this.proofCalls(e);
-    return [await this.sessionToCall(n, a), ...e];
+  async extendCallsBySession(e, t) {
+    const n = this.proofCalls(e);
+    return [await this.sessionToCall(t, n), ...e];
   }
-  async estimateInvokeFee(e, { nonce: n, blockIdentifier: a } = {}) {
-    const r = await this.extendCallsBySession(
+  async estimateInvokeFee(e, { nonce: t, blockIdentifier: n } = {}) {
+    const o = await this.extendCallsBySession(
       Array.isArray(e) ? e : [e],
       this.signedSession
-    ), o = l.toBN(n ?? await this.getNonce()), i = l.toBN(m.feeTransactionVersion), c = await this.getChainId(), d = {
+    ), r = c.toBN(t ?? await this.getNonce()), i = c.toBN(T.feeTransactionVersion), l = await this.getChainId(), d = {
       walletAddress: this.address,
-      nonce: l.toBN(o),
-      maxFee: N.ZERO,
+      nonce: c.toBN(r),
+      maxFee: P.ZERO,
       version: i,
-      chainId: c
-    }, p = await this.signer.signTransaction(
-      r,
+      chainId: l
+    }, f = await this.signer.signTransaction(
+      o,
       d
-    ), f = y.fromCallsToExecuteCalldata(r), u = await super.getInvokeEstimateFee(
+    ), m = A.fromCallsToExecuteCalldata(o), u = await super.getInvokeEstimateFee(
       {
         contractAddress: this.address,
-        calldata: f,
-        signature: p
+        calldata: m,
+        signature: f
       },
-      { version: i, nonce: o },
-      a
-    ), C = h.estimatedFeeToMaxFee(u.overall_fee);
+      { version: i, nonce: r },
+      n
+    ), h = y.estimatedFeeToMaxFee(u.overall_fee);
     return {
       ...u,
-      suggestedMaxFee: C
+      suggestedMaxFee: h
     };
   }
+  // check for resolution of any transactions that are not yet counted by account's nonce
+  async getOpenTransactionsCount() {
+    return (await Promise.all(
+      this.openTransactions.filter((t) => !!t).map((t) => this.getTransactionReceipt(t))
+    )).forEach((t) => {
+      if (t && !["NOT_RECEIVED", "RECEIVED", "PENDING"].includes(t.status)) {
+        const n = this.openTransactions.indexOf(
+          t.transaction_hash
+        );
+        n > -1 && this.openTransactions.splice(n, 1);
+      }
+    }), this.openTransactions.length;
+  }
   /**
    * Invoke execute function in account contract
    *
@@ -148,57 +162,65 @@ class L extends b {
    * @param transactionsDetail - optional transaction details
    * @returns a confirmation of invoking a function on the starknet contract
    */
-  async execute(e, n = void 0, a = {}) {
-    const r = await this.extendCallsBySession(
+  async execute(e, t = void 0, n = {}) {
+    const o = await this.extendCallsBySession(
       Array.isArray(e) ? e : [e],
       this.signedSession
-    ), o = l.toBN(
-      a.nonce ?? await this.getNonce()
+    ), r = c.toBN(
+      n.nonce ?? await this.getNonce()
     );
     let i = "0";
-    if (a.maxFee || a.maxFee === 0)
-      i = a.maxFee;
+    if (n.maxFee || n.maxFee === 0)
+      i = n.maxFee;
     else {
-      const { suggestedMaxFee: u } = await this.estimateInvokeFee(
+      const { suggestedMaxFee: p } = await this.estimateInvokeFee(
         Array.isArray(e) ? e : [e],
         {
-          nonce: o
+          nonce: r
         }
       );
-      i = u.toString();
+      i = p.toString();
     }
-    const c = l.toBN(m.transactionVersion), d = {
+    const l = c.toBN(T.transactionVersion), d = n.nonce ? r : c.toBN(parseInt(r) + await this.getOpenTransactionsCount()), f = {
       walletAddress: this.address,
-      nonce: o,
+      nonce: d,
       maxFee: i,
-      version: c,
+      version: l,
       chainId: this.chainId
-    }, p = await this.signer.signTransaction(
-      r,
-      d,
-      n
-    ), f = y.fromCallsToExecuteCalldata(r);
-    return this.invokeFunction(
+    }, m = await this.signer.signTransaction(
+      o,
+      f,
+      t
+    ), u = A.fromCallsToExecuteCalldata(o);
+    this.openTransactions.push("");
+    const h = this.invokeFunction(
       {
         contractAddress: this.address,
-        calldata: f,
-        signature: p
+        calldata: u,
+        signature: m
       },
       {
         maxFee: i,
-        version: c,
-        nonce: o
+        version: l,
+        nonce: d
       }
     );
+    return h.then((p) => {
+      const x = this.openTransactions.indexOf("");
+      x > -1 && (this.openTransactions[x] = p.transaction_hash);
+    }), h.catch(() => {
+      const p = this.openTransactions.indexOf("");
+      p > -1 && this.openTransactions.splice(p, 1);
+    }), h;
   }
 }
 export {
-  A as SESSION_PLUGIN_CLASS_HASH,
-  L as SessionAccount,
+  C as SESSION_PLUGIN_CLASS_HASH,
+  R as SessionAccount,
   S as createMerkleTreeForPolicies,
-  M as createSession,
-  L as default,
-  x as preparePolicy,
-  E as prepareSession,
-  _ as supportsSessions
+  L as createSession,
+  R as default,
+  w as preparePolicy,
+  B as prepareSession,
+  M as supportsSessions
 };
diff --git a/node_modules/@argent/x-sessions/dist/sessions.umd.cjs b/node_modules/@argent/x-sessions/dist/sessions.umd.cjs
index 4716c92..15989f0 100644
--- a/node_modules/@argent/x-sessions/dist/sessions.umd.cjs
+++ b/node_modules/@argent/x-sessions/dist/sessions.umd.cjs
@@ -1 +1 @@
-(function(s,e){typeof exports=="object"&&typeof module<"u"?e(exports,require("starknet")):typeof define=="function"&&define.amd?define(["exports","starknet"],e):(s=typeof globalThis<"u"?globalThis:s||self,e(s.sessions={},s.starknet))})(this,function(s,e){"use strict";var P=Object.defineProperty;var N=(s,e,l)=>e in s?P(s,e,{enumerable:!0,configurable:!0,writable:!0,value:l}):s[e]=l;var C=(s,e,l)=>(N(s,typeof e!="symbol"?e+"":e,l),l);const l="0x31c70ed28f4b0faf39b2f97d8f0a61a36968319c13fe6f2051b8de5a15f3d9b",T="0x2f0026e78543f036f33e26a8f5891b88c58dc1e20cbbfaf0bb53274da6fa568";async function b(i,r){const{result:t}=await r.callContract({contractAddress:i,entrypoint:"isPlugin",calldata:e.stark.compileCalldata({classHash:l})});return!e.number.toBN(t[0]).isZero()}function h({contractAddress:i,selector:r}){return e.hash.computeHashOnElements([T,i,e.typedData.prepareSelector(r)])}function m(i){return new e.merkle.MerkleTree(i.map(h))}function S(i){const{root:r}=m(i.policies);return{...i,root:r}}async function x(i,r){const{expires:t,key:n,policies:o,root:a}=S(i),c=await r.signMessage({primaryType:"Session",types:{Policy:[{name:"contractAddress",type:"felt"},{name:"selector",type:"selector"}],Session:[{name:"key",type:"felt"},{name:"expires",type:"felt"},{name:"root",type:"merkletree",contains:"Policy"}],StarkNetDomain:[{name:"chainId",type:"felt"}]},domain:{chainId:r.chainId},message:{key:n,expires:t,root:o}});return{key:n,policies:o,expires:t,root:a,signature:c}}var I=A;function A(i,r){if(!i)throw new Error(r||"Assertion failed")}A.equal=function(r,t,n){if(r!=t)throw new Error(n||"Assertion failed: "+r+" != "+t)};class w extends e.Account{constructor(t,n,o,a){super(t,n,o);C(this,"merkleTree");this.signedSession=a,this.merkleTree=m(a.policies),I(a.root===this.merkleTree.root,"Invalid session")}async sessionToCall(t,n){return{contractAddress:this.address,entrypoint:"use_plugin",calldata:e.stark.compileCalldata({classHash:l,signer:await this.signer.getPubKey(),expires:t.expires.toString(),root:t.root,proofLength:n[0].length.toString(),...n.reduce((o,a,c)=>({...o,...a.reduce((d,u,f)=>({...d,[`proof${c}:${f}`]:u}),{})}),{}),token1:t.signature[0],token2:t.signature[1]})}}proofCalls(t){return t.map(n=>{const o=h({contractAddress:n.contractAddress,selector:n.entrypoint});return this.merkleTree.getProof(o)})}async extendCallsBySession(t,n){const o=this.proofCalls(t);return[await this.sessionToCall(n,o),...t]}async estimateInvokeFee(t,{nonce:n,blockIdentifier:o}={}){const a=await this.extendCallsBySession(Array.isArray(t)?t:[t],this.signedSession),c=e.number.toBN(n??await this.getNonce()),d=e.number.toBN(e.hash.feeTransactionVersion),u=await this.getChainId(),f={walletAddress:this.address,nonce:e.number.toBN(c),maxFee:e.constants.ZERO,version:d,chainId:u},y=await this.signer.signTransaction(a,f),g=e.transaction.fromCallsToExecuteCalldata(a),p=await super.getInvokeEstimateFee({contractAddress:this.address,calldata:g,signature:y},{version:d,nonce:c},o),F=e.stark.estimatedFeeToMaxFee(p.overall_fee);return{...p,suggestedMaxFee:F}}async execute(t,n=void 0,o={}){const a=await this.extendCallsBySession(Array.isArray(t)?t:[t],this.signedSession),c=e.number.toBN(o.nonce??await this.getNonce());let d="0";if(o.maxFee||o.maxFee===0)d=o.maxFee;else{const{suggestedMaxFee:p}=await this.estimateInvokeFee(Array.isArray(t)?t:[t],{nonce:c});d=p.toString()}const u=e.number.toBN(e.hash.transactionVersion),f={walletAddress:this.address,nonce:c,maxFee:d,version:u,chainId:this.chainId},y=await this.signer.signTransaction(a,f,n),g=e.transaction.fromCallsToExecuteCalldata(a);return this.invokeFunction({contractAddress:this.address,calldata:g,signature:y},{maxFee:d,version:u,nonce:c})}}s.SESSION_PLUGIN_CLASS_HASH=l,s.SessionAccount=w,s.createMerkleTreeForPolicies=m,s.createSession=x,s.default=w,s.preparePolicy=h,s.prepareSession=S,s.supportsSessions=b,Object.defineProperties(s,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
+(function(o,e){typeof exports=="object"&&typeof module<"u"?e(exports,require("starknet")):typeof define=="function"&&define.amd?define(["exports","starknet"],e):(o=typeof globalThis<"u"?globalThis:o||self,e(o.sessions={},o.starknet))})(this,function(o,e){"use strict";var P=Object.defineProperty;var F=(o,e,d)=>e in o?P(o,e,{enumerable:!0,configurable:!0,writable:!0,value:d}):o[e]=d;var A=(o,e,d)=>(F(o,typeof e!="symbol"?e+"":e,d),d);const d="0x31c70ed28f4b0faf39b2f97d8f0a61a36968319c13fe6f2051b8de5a15f3d9b",b="0x2f0026e78543f036f33e26a8f5891b88c58dc1e20cbbfaf0bb53274da6fa568";async function E(i,a){const{result:s}=await a.callContract({contractAddress:i,entrypoint:"isPlugin",calldata:e.stark.compileCalldata({classHash:d})});return!e.number.toBN(s[0]).isZero()}function g({contractAddress:i,selector:a}){return e.hash.computeHashOnElements([b,i,e.typedData.prepareSelector(a)])}function y(i){return new e.merkle.MerkleTree(i.map(g))}function C(i){const{root:a}=y(i.policies);return{...i,root:a}}async function N(i,a){const{expires:s,key:n,policies:t,root:r}=C(i),c=await a.signMessage({primaryType:"Session",types:{Policy:[{name:"contractAddress",type:"felt"},{name:"selector",type:"selector"}],Session:[{name:"key",type:"felt"},{name:"expires",type:"felt"},{name:"root",type:"merkletree",contains:"Policy"}],StarkNetDomain:[{name:"chainId",type:"felt"}]},domain:{chainId:a.chainId},message:{key:n,expires:s,root:t}});return{key:n,policies:t,expires:s,root:r,signature:c}}var v=I;function I(i,a){if(!i)throw new Error(a||"Assertion failed")}I.equal=function(a,s,n){if(a!=s)throw new Error(n||"Assertion failed: "+a+" != "+s)};class w extends e.Account{constructor(s,n,t,r){super(s,n,t);A(this,"merkleTree");A(this,"openTransactions",[]);this.signedSession=r,this.merkleTree=y(r.policies),v(r.root===this.merkleTree.root,"Invalid session")}async sessionToCall(s,n){return{contractAddress:this.address,entrypoint:"use_plugin",calldata:e.stark.compileCalldata({classHash:d,signer:await this.signer.getPubKey(),expires:s.expires.toString(),root:s.root,proofLength:n[0].length.toString(),...n.reduce((t,r,c)=>({...t,...r.reduce((l,u,p)=>({...l,[`proof${c}:${p}`]:u}),{})}),{}),token1:s.signature[0],token2:s.signature[1]})}}proofCalls(s){return s.map(n=>{const t=g({contractAddress:n.contractAddress,selector:n.entrypoint});return this.merkleTree.getProof(t)})}async extendCallsBySession(s,n){const t=this.proofCalls(s);return[await this.sessionToCall(n,t),...s]}async estimateInvokeFee(s,{nonce:n,blockIdentifier:t}={}){const r=await this.extendCallsBySession(Array.isArray(s)?s:[s],this.signedSession),c=e.number.toBN(n??await this.getNonce()),l=e.number.toBN(e.hash.feeTransactionVersion),u=await this.getChainId(),p={walletAddress:this.address,nonce:e.number.toBN(c),maxFee:e.constants.ZERO,version:l,chainId:u},S=await this.signer.signTransaction(r,p),T=e.transaction.fromCallsToExecuteCalldata(r),m=await super.getInvokeEstimateFee({contractAddress:this.address,calldata:T,signature:S},{version:l,nonce:c},t),f=e.stark.estimatedFeeToMaxFee(m.overall_fee);return{...m,suggestedMaxFee:f}}async getOpenTransactionsCount(){return(await Promise.all(this.openTransactions.filter(n=>!!n).map(n=>this.getTransactionReceipt(n)))).forEach(n=>{if(n&&!["NOT_RECEIVED","RECEIVED","PENDING"].includes(n.status)){const t=this.openTransactions.indexOf(n.transaction_hash);t>-1&&this.openTransactions.splice(t,1)}}),this.openTransactions.length}async execute(s,n=void 0,t={}){const r=await this.extendCallsBySession(Array.isArray(s)?s:[s],this.signedSession),c=e.number.toBN(t.nonce??await this.getNonce());let l="0";if(t.maxFee||t.maxFee===0)l=t.maxFee;else{const{suggestedMaxFee:h}=await this.estimateInvokeFee(Array.isArray(s)?s:[s],{nonce:c});l=h.toString()}const u=e.number.toBN(e.hash.transactionVersion),p=t.nonce?c:e.number.toBN(parseInt(c)+await this.getOpenTransactionsCount()),S={walletAddress:this.address,nonce:p,maxFee:l,version:u,chainId:this.chainId},T=await this.signer.signTransaction(r,S,n),m=e.transaction.fromCallsToExecuteCalldata(r);this.openTransactions.push("");const f=this.invokeFunction({contractAddress:this.address,calldata:m,signature:T},{maxFee:l,version:u,nonce:p});return f.then(h=>{const x=this.openTransactions.indexOf("");x>-1&&(this.openTransactions[x]=h.transaction_hash)}),f.catch(()=>{const h=this.openTransactions.indexOf("");h>-1&&this.openTransactions.splice(h,1)}),f}}o.SESSION_PLUGIN_CLASS_HASH=d,o.SessionAccount=w,o.createMerkleTreeForPolicies=y,o.createSession=N,o.default=w,o.preparePolicy=g,o.prepareSession=C,o.supportsSessions=E,Object.defineProperties(o,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
