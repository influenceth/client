diff --git a/node_modules/@argent/x-sessions/dist/account.d.ts b/node_modules/@argent/x-sessions/dist/account.d.ts
index 0f0ac18..f3c233d 100644
--- a/node_modules/@argent/x-sessions/dist/account.d.ts
+++ b/node_modules/@argent/x-sessions/dist/account.d.ts
@@ -3,11 +3,14 @@ import { SignedSession } from "./utils";
 export declare class SessionAccount extends Account implements AccountInterface {
     signedSession: SignedSession;
     merkleTree: merkle.MerkleTree;
+    pendingTransactionHashes: string[];
+    private pendingExecuteCalls;
     constructor(providerOrOptions: ProviderOptions | ProviderInterface, address: string, keyPairOrSigner: KeyPair | SignerInterface, signedSession: SignedSession);
     private sessionToCall;
     private proofCalls;
     private extendCallsBySession;
     estimateInvokeFee(calls: Call | Call[], { nonce: providedNonce, blockIdentifier }?: EstimateFeeDetails): Promise<EstimateFee>;
+    getPendingTransactionsCount(): Promise<number>;
     /**
      * Invoke execute function in account contract
      *
diff --git a/node_modules/@argent/x-sessions/dist/sessions.js b/node_modules/@argent/x-sessions/dist/sessions.js
index 9620562..af274e2 100644
--- a/node_modules/@argent/x-sessions/dist/sessions.js
+++ b/node_modules/@argent/x-sessions/dist/sessions.js
@@ -1,32 +1,32 @@
-var k = Object.defineProperty;
-var T = (s, t, e) => t in s ? k(s, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[t] = e;
-var g = (s, t, e) => (T(s, typeof t != "symbol" ? t + "" : t, e), e);
-import { stark as h, number as l, hash as m, typedData as F, merkle as I, Account as b, constants as N, transaction as y } from "starknet";
-const A = "0x31c70ed28f4b0faf39b2f97d8f0a61a36968319c13fe6f2051b8de5a15f3d9b", v = "0x2f0026e78543f036f33e26a8f5891b88c58dc1e20cbbfaf0bb53274da6fa568";
-async function _(s, t) {
-  const { result: e } = await t.callContract({
-    contractAddress: s,
+var E = Object.defineProperty;
+var S = (n, s, e) => s in n ? E(n, s, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[s] = e;
+var h = (n, s, e) => (S(n, typeof s != "symbol" ? s + "" : s, e), e);
+import { stark as m, number as c, hash as y, typedData as k, merkle as N, Account as I, constants as F, transaction as x } from "starknet";
+const C = "0x31c70ed28f4b0faf39b2f97d8f0a61a36968319c13fe6f2051b8de5a15f3d9b", P = "0x2f0026e78543f036f33e26a8f5891b88c58dc1e20cbbfaf0bb53274da6fa568";
+async function _(n, s) {
+  const { result: e } = await s.callContract({
+    contractAddress: n,
     entrypoint: "isPlugin",
-    calldata: h.compileCalldata({ classHash: A })
+    calldata: m.compileCalldata({ classHash: C })
   });
-  return !l.toBN(e[0]).isZero();
+  return !c.toBN(e[0]).isZero();
 }
-function x({ contractAddress: s, selector: t }) {
-  return m.computeHashOnElements([
-    v,
-    s,
-    F.prepareSelector(t)
+function T({ contractAddress: n, selector: s }) {
+  return y.computeHashOnElements([
+    P,
+    n,
+    k.prepareSelector(s)
   ]);
 }
-function S(s) {
-  return new I.MerkleTree(s.map(x));
+function A(n) {
+  return new N.MerkleTree(n.map(T));
 }
-function E(s) {
-  const { root: t } = S(s.policies);
-  return { ...s, root: t };
+function B(n) {
+  const { root: s } = A(n.policies);
+  return { ...n, root: s };
 }
-async function M(s, t) {
-  const { expires: e, key: n, policies: a, root: r } = E(s), o = await t.signMessage({
+async function M(n, s) {
+  const { expires: e, key: t, policies: a, root: i } = B(n), r = await s.signMessage({
     primaryType: "Session",
     types: {
       Policy: [
@@ -41,53 +41,55 @@ async function M(s, t) {
       StarkNetDomain: [{ name: "chainId", type: "felt" }]
     },
     domain: {
-      chainId: t.chainId
+      chainId: s.chainId
     },
     message: {
-      key: n,
+      key: t,
       expires: e,
       root: a
       // we can pass the policy to the message, when argent x works with type merkletree (starknet.js update)
     }
   });
   return {
-    key: n,
+    key: t,
     policies: a,
     expires: e,
-    root: r,
-    signature: o
+    root: i,
+    signature: r
   };
 }
-var P = w;
-function w(s, t) {
-  if (!s)
-    throw new Error(t || "Assertion failed");
+var b = w;
+function w(n, s) {
+  if (!n)
+    throw new Error(s || "Assertion failed");
 }
-w.equal = function(t, e, n) {
-  if (t != e)
-    throw new Error(n || "Assertion failed: " + t + " != " + e);
+w.equal = function(s, e, t) {
+  if (s != e)
+    throw new Error(t || "Assertion failed: " + s + " != " + e);
 };
-class L extends b {
-  constructor(e, n, a, r) {
-    super(e, n, a);
-    g(this, "merkleTree");
-    this.signedSession = r, this.merkleTree = S(r.policies), P(r.root === this.merkleTree.root, "Invalid session");
+class O extends I {
+  constructor(e, t, a, i) {
+    super(e, t, a);
+    h(this, "merkleTree");
+    h(this, "pendingTransactionHashes", []);
+    h(this, "pendingExecuteCalls", 0);
+    this.signedSession = i, this.merkleTree = A(i.policies), b(i.root === this.merkleTree.root, "Invalid session");
   }
-  async sessionToCall(e, n) {
+  async sessionToCall(e, t) {
     return {
       contractAddress: this.address,
       entrypoint: "use_plugin",
-      calldata: h.compileCalldata({
-        classHash: A,
+      calldata: m.compileCalldata({
+        classHash: C,
         signer: await this.signer.getPubKey(),
         expires: e.expires.toString(),
         root: e.root,
-        proofLength: n[0].length.toString(),
-        ...n.reduce(
-          (a, r, o) => ({
+        proofLength: t[0].length.toString(),
+        ...t.reduce(
+          (a, i, r) => ({
             ...a,
-            ...r.reduce(
-              (i, c, d) => ({ ...i, [`proof${o}:${d}`]: c }),
+            ...i.reduce(
+              (o, d, l) => ({ ...o, [`proof${r}:${l}`]: d }),
               {}
             )
           }),
@@ -99,45 +101,60 @@ class L extends b {
     };
   }
   proofCalls(e) {
-    return e.map((n) => {
-      const a = x({
-        contractAddress: n.contractAddress,
-        selector: n.entrypoint
+    return e.map((t) => {
+      const a = T({
+        contractAddress: t.contractAddress,
+        selector: t.entrypoint
       });
       return this.merkleTree.getProof(a);
     });
   }
-  async extendCallsBySession(e, n) {
+  async extendCallsBySession(e, t) {
     const a = this.proofCalls(e);
-    return [await this.sessionToCall(n, a), ...e];
+    return [await this.sessionToCall(t, a), ...e];
   }
-  async estimateInvokeFee(e, { nonce: n, blockIdentifier: a } = {}) {
-    const r = await this.extendCallsBySession(
+  async estimateInvokeFee(e, { nonce: t, blockIdentifier: a } = {}) {
+    const i = await this.extendCallsBySession(
       Array.isArray(e) ? e : [e],
       this.signedSession
-    ), o = l.toBN(n ?? await this.getNonce()), i = l.toBN(m.feeTransactionVersion), c = await this.getChainId(), d = {
+    ), r = c.toBN(t ?? await this.getNonce()), o = c.toBN(y.feeTransactionVersion), d = await this.getChainId(), l = {
       walletAddress: this.address,
-      nonce: l.toBN(o),
-      maxFee: N.ZERO,
-      version: i,
-      chainId: c
+      nonce: c.toBN(r),
+      maxFee: F.ZERO,
+      version: o,
+      chainId: d
     }, p = await this.signer.signTransaction(
-      r,
-      d
-    ), f = y.fromCallsToExecuteCalldata(r), u = await super.getInvokeEstimateFee(
+      i,
+      l
+    ), g = x.fromCallsToExecuteCalldata(i), u = await super.getInvokeEstimateFee(
       {
         contractAddress: this.address,
-        calldata: f,
+        calldata: g,
         signature: p
       },
-      { version: i, nonce: o },
+      { version: o, nonce: r },
       a
-    ), C = h.estimatedFeeToMaxFee(u.overall_fee);
+    ), f = m.estimatedFeeToMaxFee(u.overall_fee);
     return {
       ...u,
-      suggestedMaxFee: C
+      suggestedMaxFee: f
     };
   }
+  // check for resolution of any transactions that are not yet counted by account's nonce
+  async getPendingTransactionsCount() {
+    try {
+      const e = await Promise.all(
+        this.pendingTransactionHashes.filter((t) => !!t).map((t) => this.getTransactionReceipt(t))
+      );
+      return this.pendingTransactionHashes = e.filter(
+        (t) => t && !["NOT_RECEIVED", "RECEIVED", "PENDING"].includes(
+          t.status ?? ""
+        )
+      ).map((t) => t.transaction_hash), this.pendingTransactionHashes.length;
+    } catch {
+      return 0;
+    }
+  }
   /**
    * Invoke execute function in account contract
    *
@@ -148,57 +165,65 @@ class L extends b {
    * @param transactionsDetail - optional transaction details
    * @returns a confirmation of invoking a function on the starknet contract
    */
-  async execute(e, n = void 0, a = {}) {
-    const r = await this.extendCallsBySession(
+  async execute(e, t = void 0, a = {}) {
+    const i = await this.extendCallsBySession(
       Array.isArray(e) ? e : [e],
       this.signedSession
-    ), o = l.toBN(
+    ), r = c.toBN(
       a.nonce ?? await this.getNonce()
     );
-    let i = "0";
+    let o = "0";
     if (a.maxFee || a.maxFee === 0)
-      i = a.maxFee;
+      o = a.maxFee;
     else {
-      const { suggestedMaxFee: u } = await this.estimateInvokeFee(
+      const { suggestedMaxFee: f } = await this.estimateInvokeFee(
         Array.isArray(e) ? e : [e],
         {
-          nonce: o
+          nonce: r
         }
       );
-      i = u.toString();
+      o = f.toString();
     }
-    const c = l.toBN(m.transactionVersion), d = {
+    const d = c.toBN(y.transactionVersion);
+    let l = c.toBN(r);
+    a.nonce || (l = r.add(c.toBN(await this.getPendingTransactionsCount())).add(c.toBN(this.pendingExecuteCalls)));
+    const p = {
       walletAddress: this.address,
-      nonce: o,
-      maxFee: i,
-      version: c,
+      nonce: l,
+      maxFee: o,
+      version: d,
       chainId: this.chainId
-    }, p = await this.signer.signTransaction(
-      r,
-      d,
-      n
-    ), f = y.fromCallsToExecuteCalldata(r);
-    return this.invokeFunction(
-      {
-        contractAddress: this.address,
-        calldata: f,
-        signature: p
-      },
-      {
-        maxFee: i,
-        version: c,
-        nonce: o
-      }
-    );
+    }, g = await this.signer.signTransaction(
+      i,
+      p,
+      t
+    ), u = x.fromCallsToExecuteCalldata(i);
+    this.pendingExecuteCalls += 1;
+    try {
+      return this.invokeFunction(
+        {
+          contractAddress: this.address,
+          calldata: u,
+          signature: g
+        },
+        {
+          maxFee: o,
+          version: d,
+          nonce: l
+        }
+      );
+    } finally {
+      this.pendingExecuteCalls = Math.max(this.pendingExecuteCalls - 1, 0);
+    }
   }
 }
 export {
-  A as SESSION_PLUGIN_CLASS_HASH,
-  L as SessionAccount,
-  S as createMerkleTreeForPolicies,
+  C as SESSION_PLUGIN_CLASS_HASH,
+  O as SessionAccount,
+  A as createMerkleTreeForPolicies,
   M as createSession,
-  L as default,
-  x as preparePolicy,
-  E as prepareSession,
+  O as default,
+  T as preparePolicy,
+  B as prepareSession,
   _ as supportsSessions
 };
diff --git a/node_modules/@argent/x-sessions/dist/sessions.umd.cjs b/node_modules/@argent/x-sessions/dist/sessions.umd.cjs
index 4716c92..406b74f 100644
--- a/node_modules/@argent/x-sessions/dist/sessions.umd.cjs
+++ b/node_modules/@argent/x-sessions/dist/sessions.umd.cjs
@@ -1 +1 @@
-(function(s,e){typeof exports=="object"&&typeof module<"u"?e(exports,require("starknet")):typeof define=="function"&&define.amd?define(["exports","starknet"],e):(s=typeof globalThis<"u"?globalThis:s||self,e(s.sessions={},s.starknet))})(this,function(s,e){"use strict";var P=Object.defineProperty;var N=(s,e,l)=>e in s?P(s,e,{enumerable:!0,configurable:!0,writable:!0,value:l}):s[e]=l;var C=(s,e,l)=>(N(s,typeof e!="symbol"?e+"":e,l),l);const l="0x31c70ed28f4b0faf39b2f97d8f0a61a36968319c13fe6f2051b8de5a15f3d9b",T="0x2f0026e78543f036f33e26a8f5891b88c58dc1e20cbbfaf0bb53274da6fa568";async function b(i,r){const{result:t}=await r.callContract({contractAddress:i,entrypoint:"isPlugin",calldata:e.stark.compileCalldata({classHash:l})});return!e.number.toBN(t[0]).isZero()}function h({contractAddress:i,selector:r}){return e.hash.computeHashOnElements([T,i,e.typedData.prepareSelector(r)])}function m(i){return new e.merkle.MerkleTree(i.map(h))}function S(i){const{root:r}=m(i.policies);return{...i,root:r}}async function x(i,r){const{expires:t,key:n,policies:o,root:a}=S(i),c=await r.signMessage({primaryType:"Session",types:{Policy:[{name:"contractAddress",type:"felt"},{name:"selector",type:"selector"}],Session:[{name:"key",type:"felt"},{name:"expires",type:"felt"},{name:"root",type:"merkletree",contains:"Policy"}],StarkNetDomain:[{name:"chainId",type:"felt"}]},domain:{chainId:r.chainId},message:{key:n,expires:t,root:o}});return{key:n,policies:o,expires:t,root:a,signature:c}}var I=A;function A(i,r){if(!i)throw new Error(r||"Assertion failed")}A.equal=function(r,t,n){if(r!=t)throw new Error(n||"Assertion failed: "+r+" != "+t)};class w extends e.Account{constructor(t,n,o,a){super(t,n,o);C(this,"merkleTree");this.signedSession=a,this.merkleTree=m(a.policies),I(a.root===this.merkleTree.root,"Invalid session")}async sessionToCall(t,n){return{contractAddress:this.address,entrypoint:"use_plugin",calldata:e.stark.compileCalldata({classHash:l,signer:await this.signer.getPubKey(),expires:t.expires.toString(),root:t.root,proofLength:n[0].length.toString(),...n.reduce((o,a,c)=>({...o,...a.reduce((d,u,f)=>({...d,[`proof${c}:${f}`]:u}),{})}),{}),token1:t.signature[0],token2:t.signature[1]})}}proofCalls(t){return t.map(n=>{const o=h({contractAddress:n.contractAddress,selector:n.entrypoint});return this.merkleTree.getProof(o)})}async extendCallsBySession(t,n){const o=this.proofCalls(t);return[await this.sessionToCall(n,o),...t]}async estimateInvokeFee(t,{nonce:n,blockIdentifier:o}={}){const a=await this.extendCallsBySession(Array.isArray(t)?t:[t],this.signedSession),c=e.number.toBN(n??await this.getNonce()),d=e.number.toBN(e.hash.feeTransactionVersion),u=await this.getChainId(),f={walletAddress:this.address,nonce:e.number.toBN(c),maxFee:e.constants.ZERO,version:d,chainId:u},y=await this.signer.signTransaction(a,f),g=e.transaction.fromCallsToExecuteCalldata(a),p=await super.getInvokeEstimateFee({contractAddress:this.address,calldata:g,signature:y},{version:d,nonce:c},o),F=e.stark.estimatedFeeToMaxFee(p.overall_fee);return{...p,suggestedMaxFee:F}}async execute(t,n=void 0,o={}){const a=await this.extendCallsBySession(Array.isArray(t)?t:[t],this.signedSession),c=e.number.toBN(o.nonce??await this.getNonce());let d="0";if(o.maxFee||o.maxFee===0)d=o.maxFee;else{const{suggestedMaxFee:p}=await this.estimateInvokeFee(Array.isArray(t)?t:[t],{nonce:c});d=p.toString()}const u=e.number.toBN(e.hash.transactionVersion),f={walletAddress:this.address,nonce:c,maxFee:d,version:u,chainId:this.chainId},y=await this.signer.signTransaction(a,f,n),g=e.transaction.fromCallsToExecuteCalldata(a);return this.invokeFunction({contractAddress:this.address,calldata:g,signature:y},{maxFee:d,version:u,nonce:c})}}s.SESSION_PLUGIN_CLASS_HASH=l,s.SessionAccount=w,s.createMerkleTreeForPolicies=m,s.createSession=x,s.default=w,s.preparePolicy=h,s.prepareSession=S,s.supportsSessions=b,Object.defineProperties(s,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
+(function(s,e){typeof exports=="object"&&typeof module<"u"?e(exports,require("starknet")):typeof define=="function"&&define.amd?define(["exports","starknet"],e):(s=typeof globalThis<"u"?globalThis:s||self,e(s.sessions={},s.starknet))})(this,function(s,e){"use strict";var I=Object.defineProperty;var P=(s,e,l)=>e in s?I(s,e,{enumerable:!0,configurable:!0,writable:!0,value:l}):s[e]=l;var f=(s,e,l)=>(P(s,typeof e!="symbol"?e+"":e,l),l);const l="0x31c70ed28f4b0faf39b2f97d8f0a61a36968319c13fe6f2051b8de5a15f3d9b",w="0x2f0026e78543f036f33e26a8f5891b88c58dc1e20cbbfaf0bb53274da6fa568";async function x(a,o){const{result:t}=await o.callContract({contractAddress:a,entrypoint:"isPlugin",calldata:e.stark.compileCalldata({classHash:l})});return!e.number.toBN(t[0]).isZero()}function g({contractAddress:a,selector:o}){return e.hash.computeHashOnElements([w,a,e.typedData.prepareSelector(o)])}function m(a){return new e.merkle.MerkleTree(a.map(g))}function T(a){const{root:o}=m(a.policies);return{...a,root:o}}async function b(a,o){const{expires:t,key:n,policies:i,root:r}=T(a),c=await o.signMessage({primaryType:"Session",types:{Policy:[{name:"contractAddress",type:"felt"},{name:"selector",type:"selector"}],Session:[{name:"key",type:"felt"},{name:"expires",type:"felt"},{name:"root",type:"merkletree",contains:"Policy"}],StarkNetDomain:[{name:"chainId",type:"felt"}]},domain:{chainId:o.chainId},message:{key:n,expires:t,root:i}});return{key:n,policies:i,expires:t,root:r,signature:c}}var N=A;function A(a,o){if(!a)throw new Error(o||"Assertion failed")}A.equal=function(o,t,n){if(o!=t)throw new Error(n||"Assertion failed: "+o+" != "+t)};class E extends e.Account{constructor(t,n,i,r){super(t,n,i);f(this,"merkleTree");f(this,"pendingTransactionHashes",[]);f(this,"pendingExecuteCalls",0);this.signedSession=r,this.merkleTree=m(r.policies),N(r.root===this.merkleTree.root,"Invalid session")}async sessionToCall(t,n){return{contractAddress:this.address,entrypoint:"use_plugin",calldata:e.stark.compileCalldata({classHash:l,signer:await this.signer.getPubKey(),expires:t.expires.toString(),root:t.root,proofLength:n[0].length.toString(),...n.reduce((i,r,c)=>({...i,...r.reduce((d,h,u)=>({...d,[`proof${c}:${u}`]:h}),{})}),{}),token1:t.signature[0],token2:t.signature[1]})}}proofCalls(t){return t.map(n=>{const i=g({contractAddress:n.contractAddress,selector:n.entrypoint});return this.merkleTree.getProof(i)})}async extendCallsBySession(t,n){const i=this.proofCalls(t);return[await this.sessionToCall(n,i),...t]}async estimateInvokeFee(t,{nonce:n,blockIdentifier:i}={}){const r=await this.extendCallsBySession(Array.isArray(t)?t:[t],this.signedSession),c=e.number.toBN(n??await this.getNonce()),d=e.number.toBN(e.hash.feeTransactionVersion),h=await this.getChainId(),u={walletAddress:this.address,nonce:e.number.toBN(c),maxFee:e.constants.ZERO,version:d,chainId:h},y=await this.signer.signTransaction(r,u),S=e.transaction.fromCallsToExecuteCalldata(r),p=await super.getInvokeEstimateFee({contractAddress:this.address,calldata:S,signature:y},{version:d,nonce:c},i),C=e.stark.estimatedFeeToMaxFee(p.overall_fee);return{...p,suggestedMaxFee:C}}async getPendingTransactionsCount(){try{const t=await Promise.all(this.pendingTransactionHashes.filter(n=>!!n).map(n=>this.getTransactionReceipt(n)));return this.pendingTransactionHashes=t.filter(n=>n&&!["NOT_RECEIVED","RECEIVED","PENDING"].includes(n.status??"")).map(n=>n.transaction_hash),this.pendingTransactionHashes.length}catch{return 0}}async execute(t,n=void 0,i={}){const r=await this.extendCallsBySession(Array.isArray(t)?t:[t],this.signedSession),c=e.number.toBN(i.nonce??await this.getNonce());let d="0";if(i.maxFee||i.maxFee===0)d=i.maxFee;else{const{suggestedMaxFee:C}=await this.estimateInvokeFee(Array.isArray(t)?t:[t],{nonce:c});d=C.toString()}const h=e.number.toBN(e.hash.transactionVersion);let u=e.number.toBN(c);i.nonce||(u=c.add(e.number.toBN(await this.getPendingTransactionsCount())).add(e.number.toBN(this.pendingExecuteCalls)));const y={walletAddress:this.address,nonce:u,maxFee:d,version:h,chainId:this.chainId},S=await this.signer.signTransaction(r,y,n),p=e.transaction.fromCallsToExecuteCalldata(r);this.pendingExecuteCalls+=1;try{return this.invokeFunction({contractAddress:this.address,calldata:p,signature:S},{maxFee:d,version:h,nonce:u})}finally{this.pendingExecuteCalls=Math.max(this.pendingExecuteCalls-1,0)}}}s.SESSION_PLUGIN_CLASS_HASH=l,s.SessionAccount=E,s.createMerkleTreeForPolicies=m,s.createSession=b,s.default=E,s.preparePolicy=g,s.prepareSession=T,s.supportsSessions=x,Object.defineProperties(s,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
